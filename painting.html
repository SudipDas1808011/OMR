<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Draw | Modern Canvas</title>
    <link rel="icon" type="image/png" href="assets/drawing.png">
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-bg: #f8f9fa;
            --canvas-bg: #ffffff;
            --text-color: #212529;
            --control-bg: rgba(255, 255, 255, 0.8);
            --accent-color: #4dabf7;
            --border-color: #dee2e6;
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] {
            --primary-bg: #121212;
            --canvas-bg: #1e1e1e;
            --text-color: #e9ecef;
            --control-bg: rgba(30, 30, 30, 0.8);
            --accent-color: #74c0fc;
            --border-color: #495057;
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--primary-bg);
            color: var(--text-color);
            font-family: 'Outfit', sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease;
            touch-action: none;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100vw;
            height: 100vh;
            padding: 10px;
            box-sizing: border-box;
            overflow: hidden;
        }

        header {
            margin-bottom: 10px;
            text-align: center;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: -1px;
            background: linear-gradient(45deg, var(--accent-color), #bc78ec);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            padding: 10px 20px;
            background: var(--control-bg);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            margin-bottom: 15px;
            z-index: 10;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-size: 14px;
            font-weight: 500;
            opacity: 0.8;
        }

        button {
            padding: 8px 16px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            background: var(--canvas-bg);
            color: var(--text-color);
            font-family: inherit;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        button:active {
            transform: translateY(0);
        }

        button.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        input[type="color"] {
            -webkit-appearance: none;
            appearance: none;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            background: none;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 2px solid var(--border-color);
            border-radius: 50%;
        }

        input[type="range"] {
            width: 100px;
            cursor: pointer;
        }

        .canvas-wrapper {
            position: relative;
            box-shadow: var(--shadow);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid var(--border-color);
            background-color: var(--canvas-bg);
            flex-grow: 1;
            width: 100%;
            max-width: 1400px;
            margin-bottom: 5px;
        }

        canvas {
            display: block;
            touch-action: none;
            cursor: pointer;
        }

        .action-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        #clearBtn:hover {
            background: #ff6b6b;
            border-color: #ff6b6b;
        }

        #saveBtn:hover {
            background: #51cf66;
            border-color: #51cf66;
        }

        /* Tooltip style */
        .tooltip {
            position: relative;
        }

        .value-display {
            font-variant-numeric: tabular-nums;
            min-width: 25px;
            text-align: center;
        }
    </style>
</head>

<body data-theme="light">
    <div class="app-container">
        <header>
            <h1>Pro Draw v2.0</h1>
        </header>

        <div class="controls">
            <div class="control-group">
                <label for="colorPicker">Color</label>
                <input type="color" id="colorPicker" value="#000000" title="Choose color">
            </div>

            <div class="control-group">
                <label for="penSize">Size</label>
                <input type="range" id="penSize" min="1" max="50" value="3">
                <span class="value-display" id="penSizeVal">3</span>
            </div>

            <div class="control-group">
                <button id="eraserBtn" title="Eraser"> Eraser</button>
                <button id="themeBtn" title="Toggle Theme"> Dark Mode</button>
            </div>

            <div class="control-group">
                <button id="clearBtn" title="Clear Canvas"> Clear All</button>
                <button id="saveBtn" title="Download Image"> Save Image</button>
            </div>
        </div>

        <div class="canvas-wrapper">
            <canvas id="drawingCanvas"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const colorPicker = document.getElementById('colorPicker');
        const penSizeInput = document.getElementById('penSize');
        const penSizeVal = document.getElementById('penSizeVal');
        const eraserBtn = document.getElementById('eraserBtn');
        const themeBtn = document.getElementById('themeBtn');
        const clearBtn = document.getElementById('clearBtn');
        const saveBtn = document.getElementById('saveBtn');
        const body = document.body;

        let drawing = false;
        let color = colorPicker.value;
        let lineWidth = penSizeInput.value;
        let erasing = false;
        let drawingData = [];

        // Load theme from localStorage
        const savedTheme = localStorage.getItem('draw-theme') || 'light';
        body.setAttribute('data-theme', savedTheme);
        themeBtn.textContent = savedTheme === 'light' ? ' Dark Mode' : ' Light Mode';

        // Initialize Canvas
        function initCanvas() {
            // Load tool settings first
            const savedColor = localStorage.getItem('pro-draw-color');
            if (savedColor) {
                color = savedColor;
                colorPicker.value = savedColor;
            }

            const savedSize = localStorage.getItem('pro-draw-size');
            if (savedSize) {
                lineWidth = savedSize;
                penSizeInput.value = savedSize;
                penSizeVal.textContent = savedSize;
            }

            fitCanvasToContainer();

            // Load drawing from localStorage
            const savedDrawing = localStorage.getItem('pro-draw-data');
            if (savedDrawing) {
                try {
                    drawingData = JSON.parse(savedDrawing);
                    redrawCanvas();
                } catch (e) {
                    console.error("Error loading drawing data", e);
                    drawingData = [];
                }
            }
        }

        function fitCanvasToContainer() {
            const wrapper = document.querySelector('.canvas-wrapper');
            const rect = wrapper.getBoundingClientRect();

            // Set canvas size to exactly fill its flex container
            canvas.width = rect.width;
            canvas.height = rect.height;
        }

        function resizeCanvas() {
            const oldWidth = canvas.width;
            const oldHeight = canvas.height;

            fitCanvasToContainer();

            // Redraw everything accurately based on proportions
            redrawCanvas(oldWidth, oldHeight);
        }

        function redrawCanvas(oldWidth, oldHeight, targetCtx = ctx, clear = true) {
            const currentCanvas = targetCtx.canvas;
            if (clear) {
                targetCtx.clearRect(0, 0, currentCanvas.width, currentCanvas.height);
            }

            const scaleX = oldWidth ? currentCanvas.width / oldWidth : 1;
            const scaleY = oldHeight ? currentCanvas.height / oldHeight : 1;

            drawingData.forEach(path => {
                if (path.points.length < 1) return;

                targetCtx.beginPath();
                // Use destination-out for eraser to truly "remove" content
                targetCtx.globalCompositeOperation = path.isEraser ? 'destination-out' : 'source-over';
                targetCtx.strokeStyle = path.color;
                targetCtx.lineWidth = path.lineWidth;
                targetCtx.lineCap = 'round';
                targetCtx.lineJoin = 'round';

                const startX = oldWidth ? path.points[0].x * scaleX : path.points[0].x;
                const startY = oldHeight ? path.points[0].y * scaleY : path.points[0].y;
                targetCtx.moveTo(startX, startY);

                path.points.forEach((point, index) => {
                    const x = oldWidth ? point.x * scaleX : point.x;
                    const y = oldHeight ? point.y * scaleY : point.y;
                    targetCtx.lineTo(x, y);

                    if (oldWidth && targetCtx === ctx) {
                        point.x = x;
                        point.y = y;
                    }
                });
                targetCtx.stroke();
            });

            // Reset composite operation to default
            targetCtx.globalCompositeOperation = 'source-over';
        }

        function getPosition(event) {
            const rect = canvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function startDrawing(event) {
            drawing = true;
            const pos = getPosition(event);

            const currentPath = {
                color: color,
                isEraser: erasing,
                lineWidth: lineWidth,
                points: [pos]
            };

            drawingData.push(currentPath);

            ctx.beginPath();
            ctx.globalCompositeOperation = currentPath.isEraser ? 'destination-out' : 'source-over';
            ctx.strokeStyle = currentPath.color;
            ctx.lineWidth = currentPath.lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.moveTo(pos.x, pos.y);

            if (event.type === 'touchstart') event.preventDefault();
        }

        function draw(event) {
            if (!drawing) return;

            const pos = getPosition(event);
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();

            drawingData[drawingData.length - 1].points.push(pos);

            if (event.type === 'touchmove') event.preventDefault();
        }

        function stopDrawing() {
            if (drawing) {
                drawing = false;
                ctx.closePath();
                saveToLocalStorage();
            }
        }

        function getCanvasBgColor() {
            return getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg').trim();
        }

        function saveToLocalStorage() {
            localStorage.setItem('pro-draw-data', JSON.stringify(drawingData));
        }

        // Event Listeners
        colorPicker.addEventListener('input', (e) => {
            color = e.target.value;
            localStorage.setItem('pro-draw-color', color);
            erasing = false;
            eraserBtn.classList.remove('active');
        });

        penSizeInput.addEventListener('input', (e) => {
            lineWidth = e.target.value;
            penSizeVal.textContent = lineWidth;
            localStorage.setItem('pro-draw-size', lineWidth);
        });

        eraserBtn.addEventListener('click', () => {
            erasing = !erasing;
            eraserBtn.classList.toggle('active', erasing);
        });

        themeBtn.addEventListener('click', () => {
            const currentTheme = body.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            body.setAttribute('data-theme', newTheme);
            themeBtn.textContent = newTheme === 'light' ? ' Dark Mode' : ' Light Mode';
            localStorage.setItem('draw-theme', newTheme);

            // Re-render to update eraser background color
            redrawCanvas();
        });

        clearBtn.addEventListener('click', () => {
            if (confirm('Clear everything?')) {
                drawingData = [];
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                saveToLocalStorage();
            }
        });

        saveBtn.addEventListener('click', () => {
            // 1. Create a scratch canvas to draw all paths with transparency
            const scratchCanvas = document.createElement('canvas');
            scratchCanvas.width = canvas.width;
            scratchCanvas.height = canvas.height;
            const sCtx = scratchCanvas.getContext('2d');

            // Draw everything onto scratch (handles erasers as transparent holes)
            redrawCanvas(0, 0, sCtx);

            // 2. Create the final canvas with the theme background
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = canvas.width;
            finalCanvas.height = canvas.height;
            const fCtx = finalCanvas.getContext('2d');

            // Fill theme background
            fCtx.fillStyle = getCanvasBgColor();
            fCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);

            // Draw the scratch canvas (drawing + holes) onto the background
            fCtx.drawImage(scratchCanvas, 0, 0);

            const link = document.createElement('a');
            link.download = `drawing-${Date.now()}.png`;
            link.href = finalCanvas.toDataURL('image/png');
            link.click();
        });

        // Mouse Events
        canvas.addEventListener('mousedown', startDrawing);
        window.addEventListener('mousemove', draw);
        window.addEventListener('mouseup', stopDrawing);

        // Touch Events
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);

        window.addEventListener('resize', resizeCanvas);

        // Init
        initCanvas();
    </script>
</body>

</html>