<!DOCTYPE html>
<html lang="bn">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Drawable Flashcards (Front/Back, Save/Load, Play)</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #22c55e;
      --danger: #ef4444;
      --primary: #3b82f6;
      --border: #1f2937;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto;
      background: linear-gradient(180deg, #0b1221, #0f172a);
      color: var(--text);
    }
    header {
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      background: rgba(15,23,42,0.9);
      backdrop-filter: blur(8px);
      z-index: 10;
    }
    .title {
      font-weight: 700;
      font-size: 18px;
      letter-spacing: 0.2px;
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
      align-items: center;
    }
    button, label[role="button"] {
      background: #0b253f;
      color: var(--text);
      border: 1px solid #1e3a8a;
      border-radius: 8px;
      padding: 8px 12px;
      cursor: pointer;
      transition: 120ms ease all;
      font-weight: 600;
    }
    button:hover, label[role="button"]:hover {
      background: #0a2a52;
      border-color: #2563eb;
    }
    button.primary { background: #0a2a52; border-color: #2563eb; }
    button.success { background: #06351f; border-color: #16a34a; }
    button.warning { background: #3a2708; border-color: #f59e0b; }
    button.danger { background: #3a0a0a; border-color: #ef4444; }
    .row {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 16px;
      padding: 16px;
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
    }
    .panel h3 {
      margin: 0 0 10px 0;
      font-size: 15px;
      color: var(--muted);
      font-weight: 700;
    }
    .controls {
      display: grid;
      gap: 10px;
    }
    .control-group {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .control-group .label {
      font-size: 13px;
      color: var(--muted);
      min-width: 90px;
    }
    input[type="color"], input[type="range"] {
      accent-color: var(--primary);
    }
    .stage {
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 10px;
    }
    .canvas-wrap {
      position: relative;
      border: 1px dashed #334155;
      border-radius: 12px;
      background: #0b1221;
      overflow: hidden;
    }
    .canvas-wrap .side-label {
      position: absolute;
      top: 8px; left: 12px;
      font-size: 12px; color: #93c5fd;
      background: rgba(2,6,23,0.6);
      padding: 4px 8px; border-radius: 6px;
      border: 1px solid #1f2937;
    }
    canvas {
      display: block;
      width: 100%;
      height: 520px;
      touch-action: none; /* pointer events for pen/touch */
      background: #0a0f1c;
    }
    .card-nav {
      display: flex; gap: 8px; align-items: center; justify-content: space-between;
    }
    .card-nav .left, .card-nav .right {
      display: flex; gap: 8px; align-items: center;
    }
    .badge {
      background: #0b253f;
      border: 1px solid #1e3a8a;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: #93c5fd;
    }
    .file-input {
      display: none;
    }
    .hint {
      margin-top: 6px;
      font-size: 12px;
      color: #9ca3af;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 10px;
    }
    .thumb {
      border: 1px solid #334155;
      border-radius: 8px;
      overflow: hidden;
      background: #0a0f1c;
      cursor: pointer;
    }
    .thumb img {
      width: 100%; height: 100px; object-fit: cover;
      display: block;
    }
    .thumb .meta {
      font-size: 11px; color: #9ca3af; padding: 6px 8px;
      display: flex; justify-content: space-between; align-items: center;
    }
    .thumb.active { outline: 2px solid #2563eb; }
    .playbar {
      display: flex; gap: 8px; align-items: center;
    }
  </style>
</head>
<body>
  <header>
    <div class="title">Drawable Flashcards — Front/Back, Save/Load, Play</div>
    <div class="toolbar">
      <button id="newCardBtn" class="primary">+ New Card</button>
      <button id="saveBtn" class="success">Save</button>
      <label for="fileInput" role="button" class="warning">Load JSON</label>
      <input id="fileInput" class="file-input" type="file" accept="application/json" />
      <button id="playBtn">Play</button>
      <button id="stopBtn" class="danger" style="display:none;">Stop</button>
      <span class="badge" id="statusBadge">Edit mode</span>
    </div>
  </header>

  <main class="row">
    <aside class="panel">
      <h3>Drawing tools</h3>
      <div class="controls">
        <div class="control-group">
          <span class="label">Brush color</span>
          <input type="color" id="colorPicker" value="#ffffff" />
        </div>
        <div class="control-group">
          <span class="label">Brush size</span>
          <input type="range" id="sizePicker" min="1" max="36" value="4" />
          <span id="sizeLabel" class="badge">4 px</span>
        </div>
        <div class="control-group">
          <span class="label">Side</span>
          <button id="frontSideBtn" class="primary">Front</button>
          <button id="backSideBtn">Back</button>
        </div>
        <div class="control-group">
          <button id="clearBtn" class="danger">Clear</button>
        </div>
        <div class="hint">Pen, mouse বা touch—সবই চলবে. Pointer events সক্রিয় আছে।</div>
      </div>

      <h3 style="margin-top:16px;">Cards</h3>
      <div id="thumbGrid" class="grid"></div>
    </aside>

    <section class="panel stage">
      <div class="card-nav">
        <div class="left">
          <span class="badge">Card <span id="cardIndexLabel">1</span>/<span id="cardCountLabel">0</span></span>
          <span class="badge">Side: <span id="sideLabel">Front</span></span>
        </div>
        <div class="right">
          <button id="prevBtn">Prev</button>
          <button id="flipBtn">Flip</button>
          <button id="nextBtn">Next</button>
        </div>
      </div>

      <div class="canvas-wrap">
        <div class="side-label">Draw here</div>
        <canvas id="drawCanvas" width="1280" height="720"></canvas>
      </div>

      <div class="playbar">
        <span class="hint">Tip: Flip (Space), Prev (←), Next (→). Save করে JSON রাখতে ভুলবে না।</span>
      </div>
    </section>
  </main>

  <script>
    // ---------- State ----------
    const canvas = document.getElementById('drawCanvas');
    const ctx = canvas.getContext('2d');

    const colorPicker = document.getElementById('colorPicker');
    const sizePicker  = document.getElementById('sizePicker');
    const sizeLabel   = document.getElementById('sizeLabel');

    const frontSideBtn = document.getElementById('frontSideBtn');
    const backSideBtn  = document.getElementById('backSideBtn');
    const clearBtn     = document.getElementById('clearBtn');

    const newCardBtn   = document.getElementById('newCardBtn');
    const saveBtn      = document.getElementById('saveBtn');
    const fileInput    = document.getElementById('fileInput');

    const playBtn      = document.getElementById('playBtn');
    const stopBtn      = document.getElementById('stopBtn');
    const statusBadge  = document.getElementById('statusBadge');

    const prevBtn      = document.getElementById('prevBtn');
    const flipBtn      = document.getElementById('flipBtn');
    const nextBtn      = document.getElementById('nextBtn');

    const cardIndexLabel = document.getElementById('cardIndexLabel');
    const cardCountLabel = document.getElementById('cardCountLabel');
    const sideLabel      = document.getElementById('sideLabel');
    const thumbGrid      = document.getElementById('thumbGrid');

    let cards = []; // { front: dataURL, back: dataURL }
    let currentIndex = -1;
    let currentSide = 'front';
    let drawing = false;
    let playing = false;

    // ---------- Init ----------
    function initCanvas() {
      ctx.fillStyle = '#0a0f1c';
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }
    function ensureAtLeastOneCard() {
      if (cards.length === 0) {
        cards.push({ front: null, back: null });
        currentIndex = 0;
      }
      updateUI();
      loadSideToCanvas();
    }
    initCanvas();
    ensureAtLeastOneCard();

    // ---------- Drawing ----------
    function getCanvasPos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) * (canvas.width / rect.width),
        y: (e.clientY - rect.top) * (canvas.height / rect.height)
      };
    }

    sizePicker.addEventListener('input', () => {
      sizeLabel.textContent = sizePicker.value + ' px';
    });

    function beginStroke(e) {
      if (playing) return;
      drawing = true;
      const { x, y } = getCanvasPos(e);
      ctx.strokeStyle = colorPicker.value;
      ctx.lineWidth = parseFloat(sizePicker.value);
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(x, y);
    }
    function continueStroke(e) {
      if (!drawing) return;
      const { x, y } = getCanvasPos(e);
      ctx.lineTo(x, y);
      ctx.stroke();
    }
    function endStroke() {
      if (!drawing) return;
      drawing = false;
      ctx.closePath();
      saveCanvasToSide();
      renderThumbs();
    }

    // Pointer events (pen/mouse/touch)
    canvas.addEventListener('pointerdown', beginStroke);
    canvas.addEventListener('pointermove', continueStroke);
    window.addEventListener('pointerup', endStroke);
    canvas.addEventListener('pointerleave', endStroke);

    // ---------- Side / Canvas sync ----------
    function saveCanvasToSide() {
      const dataURL = canvas.toDataURL('image/png');
      if (!cards[currentIndex]) return;
      cards[currentIndex][currentSide] = dataURL;
    }

    function loadSideToCanvas() {
      initCanvas();
      const dataURL = cards[currentIndex]?.[currentSide];
      if (dataURL) {
        const img = new Image();
        img.onload = () => {
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        };
        img.src = dataURL;
      }
    }

    function setSide(side) {
      currentSide = side;
      sideLabel.textContent = side === 'front' ? 'Front' : 'Back';
      frontSideBtn.classList.toggle('primary', side === 'front');
      backSideBtn.classList.toggle('primary', side === 'back');
      loadSideToCanvas();
      highlightActiveThumb();
    }

    frontSideBtn.addEventListener('click', () => setSide('front'));
    backSideBtn.addEventListener('click',  () => setSide('back'));

    clearBtn.addEventListener('click', () => {
      if (playing) return;
      initCanvas();
      saveCanvasToSide();
      renderThumbs();
    });

    // ---------- Cards navigation ----------
    function updateUI() {
      cardIndexLabel.textContent = (currentIndex + 1);
      cardCountLabel.textContent = cards.length;
    }

    function goTo(index) {
      if (index < 0 || index >= cards.length) return;
      currentIndex = index;
      updateUI();
      loadSideToCanvas();
      highlightActiveThumb();
    }

    prevBtn.addEventListener('click', () => goTo(currentIndex - 1));
    nextBtn.addEventListener('click', () => goTo(currentIndex + 1));
    flipBtn.addEventListener('click', () => {
      setSide(currentSide === 'front' ? 'back' : 'front');
    });

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { e.preventDefault(); flipBtn.click(); }
      if (e.code === 'ArrowLeft') { prevBtn.click(); }
      if (e.code === 'ArrowRight') { nextBtn.click(); }
    });

    newCardBtn.addEventListener('click', () => {
      cards.push({ front: null, back: null });
      goTo(cards.length - 1);
      setSide('front');
      renderThumbs();
    });

    // ---------- Thumbs ----------
    function renderThumbs() {
      thumbGrid.innerHTML = '';
      cards.forEach((card, i) => {
        const el = document.createElement('div');
        el.className = 'thumb' + (i === currentIndex ? ' active' : '');
        const frontImg = document.createElement('img');
        frontImg.src = card.front || placeholderDataURL();
        const meta = document.createElement('div');
        meta.className = 'meta';
        meta.innerHTML = `
          <span>#${i+1}</span>
          <span>${card.front ? 'F✓' : 'F•'} ${card.back ? 'B✓' : 'B•'}</span>
        `;
        el.appendChild(frontImg);
        el.appendChild(meta);
        el.addEventListener('click', () => { goTo(i); });
        thumbGrid.appendChild(el);
      });
    }

    function highlightActiveThumb() {
      [...thumbGrid.querySelectorAll('.thumb')].forEach((t, i) => {
        t.classList.toggle('active', i === currentIndex);
      });
    }

    function placeholderDataURL() {
      // simple tiny placeholder
      const c = document.createElement('canvas');
      c.width = 320; c.height = 180;
      const x = c.getContext('2d');
      x.fillStyle = '#0a0f1c'; x.fillRect(0,0,c.width,c.height);
      x.strokeStyle = '#334155'; x.strokeRect(8,8,c.width-16,c.height-16);
      x.fillStyle = '#64748b';
      x.font = '12px sans-serif';
      x.fillText('No Front', 12, 20);
      return c.toDataURL('image/png');
    }

    renderThumbs();

    // ---------- Save / Load ----------
    saveBtn.addEventListener('click', () => {
      // persist current canvas state before saving
      saveCanvasToSide();
      const payload = {
        version: 1,
        createdAt: new Date().toISOString(),
        canvasSize: { width: canvas.width, height: canvas.height },
        cards
      };
      const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'flashcards.json';
      a.click();
      URL.revokeObjectURL(url);
    });

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.cards || !Array.isArray(data.cards)) {
          alert('Invalid JSON: cards array missing.');
          return;
        }
        cards = data.cards.map(c => ({ front: c.front || null, back: c.back || null }));
        currentIndex = 0;
        setSide('front');
        updateUI();
        renderThumbs();
        loadSideToCanvas();
      } catch (err) {
        alert('Failed to load JSON.');
      } finally {
        fileInput.value = '';
      }
    });

    // ---------- Play mode ----------
    playBtn.addEventListener('click', () => {
      playing = true;
      statusBadge.textContent = 'Play mode';
      playBtn.style.display = 'none';
      stopBtn.style.display = 'inline-block';
      // show front side when starting
      setSide('front');
    });

    stopBtn.addEventListener('click', () => {
      playing = false;
      statusBadge.textContent = 'Edit mode';
      stopBtn.style.display = 'none';
      playBtn.style.display = 'inline-block';
    });

    // Prevent drawing in play mode visually (cursor change optional)
    canvas.addEventListener('pointerdown', (e) => {
      if (playing) {
        // In play mode, just ignore drawing start
        e.preventDefault();
      }
    }, { capture: true });

    // ---------- Resize handling (keep drawing pixels crisp) ----------
    function resizeCanvasToDisplaySize() {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const width = Math.round(rect.width * dpr);
      const height = Math.round(rect.height * dpr);
      if (canvas.width !== width || canvas.height !== height) {
        const current = canvas.toDataURL('image/png');
        canvas.width = width;
        canvas.height = height;
        ctx.imageSmoothingEnabled = true;
        // restore image
        const img = new Image();
        img.onload = () => {
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        };
        img.src = current;
      }
    }
    new ResizeObserver(resizeCanvasToDisplaySize).observe(canvas);

    // ---------- Accessibility hints ----------
    // Simple focus styles via keyboard can be added if needed.
  </script>
</body>
</html>

