<!DOCTYPE html>
<html lang="bn">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Infinite Scroll Drawing</title>
  <link rel="icon" type="image/png" href="assets/infinity.png">
  <!-- jsPDF Library for PDF Generation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --primary: #3b82f6;
      --accent: #22c55e;
      --border: #1f2937;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto;
      background: linear-gradient(180deg, #0b1221, #0f172a);
      color: var(--text);
    }
    header {
      position: sticky; top: 0; z-index: 10;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      background: rgba(15,23,42,0.9);
      backdrop-filter: blur(8px);
    }
    .title { font-weight: 700; font-size: 18px; }
    .toolbar {
      display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-top: 8px;
    }
    button, label[role="button"], input[type="number"] {
      background: #0b253f;
      color: var(--text);
      border: 1px solid #1e3a8a;
      border-radius: 8px;
      padding: 8px 12px;
      cursor: pointer; font-weight: 600;
      transition: all 0.2s;
    }
    input[type="number"] {
      width: 80px;
      cursor: text;
      outline: none;
    }
    input[type="number"]:focus {
      border-color: var(--primary);
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    button.primary { background: #0a2a52; border-color: #2563eb; }
    button.success { background: #06351f; border-color: #16a34a; }
    button.warning { background: #3a2708; border-color: #f59e0b; }
    button.pdf-btn { background: #4338ca; border-color: #6366f1; }
    
    .nav-group {
      display: flex; gap: 4px; align-items: center; background: rgba(30, 58, 138, 0.2); padding: 4px; border-radius: 10px; border: 1px solid #1e3a8a;
    }

    .controls {
      display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
      margin-top: 10px;
    }
    .label { font-size: 13px; color: var(--muted); }
    input[type="color"], input[type="range"] { accent-color: var(--primary); }
    main { padding: 12px 16px; }
    .section {
      margin: 16px auto;
      max-width: 1000px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px; overflow: hidden;
      scroll-margin-top: 180px;
    }
    .section-head {
      display: flex; justify-content: space-between; align-items: center;
      padding: 8px 12px; border-bottom: 1px solid var(--border);
      font-size: 12px; color: var(--muted);
    }
    .canvas-wrap {
      position: relative;
      background: #0a0f1c;
      border-top: 1px dashed #334155;
    }
    canvas {
      display: block;
      width: 100%;
      height: auto;
      touch-action: none;
    }
    .hint { font-size: 12px; color: var(--muted); margin-top: 6px; }
    .file-input { display: none; }
  </style>
</head>
<body>
  <header>
    <div class="title">Infinite Scroll Drawing</div>
    <div class="toolbar">
      <div class="nav-group">
        <input type="number" id="jumpInput" placeholder="#" min="1" />
        <button id="jumpBtn">Go</button>
      </div>
      <button id="pdfBtn" class="pdf-btn">Download PDF</button>
      <button id="exportBtn" class="success">Export JSON</button>
      <label for="importInput" role="button" class="warning">Import JSON</label>
      <input id="importInput" class="file-input" type="file" accept="application/json" />
      <span class="hint" id="sectionCountLabel">Total: 3 sections</span>
    </div>
    <div class="controls">
      <span class="label">Brush color</span>
      <input type="color" id="colorPicker" value="#ffffff" />
      <span class="label" style="margin-left:8px;">Brush size</span>
      <input type="range" id="sizePicker" min="1" max="50" value="3" />
      <span id="sizeLabel" class="label">3 px</span>
      <button id="eraserBtn">Eraser</button>
      <button id="penBtn" class="primary">Pen</button>
      <button id="clearSectionBtn">Clear section</button>
    </div>
  </header>

  <main>
    <div id="sectionsContainer"></div>
  </main>

  <script>
    const STORAGE_KEY = 'infiniteDrawing_v1';
    const TILE_HEIGHT = 1600;
    const VIRTUAL_WIDTH = 1920; 
    const MIN_SECTIONS = 3;

    const container = document.getElementById('sectionsContainer');
    const exportBtn = document.getElementById('exportBtn');
    const pdfBtn = document.getElementById('pdfBtn');
    const importInput = document.getElementById('importInput');
    const colorPicker = document.getElementById('colorPicker');
    const sizePicker  = document.getElementById('sizePicker');
    const sizeLabel   = document.getElementById('sizeLabel');
    const eraserBtn   = document.getElementById('eraserBtn');
    const penBtn      = document.getElementById('penBtn');
    const clearSectionBtn = document.getElementById('clearSectionBtn');
    const jumpInput = document.getElementById('jumpInput');
    const jumpBtn = document.getElementById('jumpBtn');
    const sectionCountLabel = document.getElementById('sectionCountLabel');

    let mode = 'pen';
    let sections = [];
    let drawing = false;
    let activeSection = null;

    function updateSectionUI() {
      sectionCountLabel.textContent = `Total: ${sections.length} sections`;
      jumpInput.max = sections.length;
    }

    function createSection(index, dataURL = null) {
      const sec = document.createElement('div');
      sec.className = 'section';
      sec.id = `section-${index}`;

      const head = document.createElement('div');
      head.className = 'section-head';
      head.innerHTML = `<span>Section #${index+1}</span><span>${dataURL ? 'Loaded' : 'New'}</span>`;

      const wrap = document.createElement('div');
      wrap.className = 'canvas-wrap';

      const canvas = document.createElement('canvas');
      canvas.width = VIRTUAL_WIDTH;
      canvas.height = TILE_HEIGHT;

      const ctx = canvas.getContext('2d', { alpha: false });
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      ctx.fillStyle = '#0a0f1c';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (dataURL) {
        const img = new Image();
        img.onload = () => {
          ctx.drawImage(img, 0, 0, VIRTUAL_WIDTH, TILE_HEIGHT);
        };
        img.src = dataURL;
      }

      wrap.appendChild(canvas);
      sec.appendChild(head);
      sec.appendChild(wrap);
      container.appendChild(sec);

      const sectionObj = { index, canvas, ctx, element: sec, dataURL: dataURL || null };
      sections[index] = sectionObj;

      canvas.addEventListener('pointerdown', (e) => beginStroke(e, sectionObj));
      canvas.addEventListener('pointermove', (e) => continueStroke(e, sectionObj));
      window.addEventListener('pointerup', () => endStroke(sectionObj));
      canvas.addEventListener('pointerleave', () => endStroke(sectionObj));

      updateSectionUI();
      return sectionObj;
    }

    jumpBtn.addEventListener('click', () => {
      const val = parseInt(jumpInput.value);
      if (val >= 1 && val <= sections.length) {
        const target = sections[val - 1].element;
        target.scrollIntoView({ behavior: 'smooth' });
      } else {
        alert(`Please enter a number between 1 and ${sections.length}`);
      }
    });

    jumpInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') jumpBtn.click();
    });

    function getPosInCanvas(e, canvas) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
      };
    }

    function beginStroke(e, section) {
      activeSection = section;
      drawing = true;
      const { ctx, canvas } = section;
      const { x, y } = getPosInCanvas(e, canvas);

      if (mode === 'pen') {
        ctx.strokeStyle = colorPicker.value;
        ctx.lineWidth = parseFloat(sizePicker.value);
        ctx.globalCompositeOperation = 'source-over';
      } else {
        ctx.strokeStyle = '#0a0f1c';
        ctx.lineWidth = parseFloat(sizePicker.value) * 3;
        ctx.globalCompositeOperation = 'source-over';
      }

      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(x, y);
    }

    function continueStroke(e, section) {
      if (!drawing || activeSection !== section) return;
      const { ctx, canvas } = section;
      const { x, y } = getPosInCanvas(e, canvas);
      ctx.lineTo(x, y);
      ctx.stroke();
    }

    function endStroke(section) {
      if (!drawing || activeSection !== section) return;
      drawing = false;
      section.ctx.closePath();
      section.dataURL = section.canvas.toDataURL('image/png', 1.0);
      persistToLocalStorage();
    }

    function persistToLocalStorage() {
      const payload = {
        version: 2,
        sections: sections.map(s => ({ index: s.index, dataURL: s.dataURL }))
      };
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      } catch (err) {
        console.warn('LocalStorage limit reached');
      }
    }

    function loadFromLocalStorage() {
      const text = localStorage.getItem(STORAGE_KEY);
      if (!text) return null;
      try {
        return JSON.parse(text);
      } catch {
        return null;
      }
    }

    function ensureMoreSectionsIfNeeded() {
      const scrolledBottom = window.scrollY + window.innerHeight;
      const docHeight = document.documentElement.scrollHeight;
      if (docHeight - scrolledBottom < 1000) {
        addSection();
      }
    }

    function addSection(dataURL = null) {
      const idx = sections.length;
      createSection(idx, dataURL);
    }

    window.addEventListener('scroll', ensureMoreSectionsIfNeeded);

    // PDF Export with High Precision and Scaling to fit Width
    pdfBtn.addEventListener('click', async () => {
      const { jsPDF } = window.jspdf;
      
      pdfBtn.textContent = 'Processing PDF...';
      pdfBtn.disabled = true;

      try {
        // Standard A4 width in points is approx 595.
        // We will scale our 1920px canvas to fit exactly within this width.
        const pdf = new jsPDF('p', 'pt', 'a4');
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        
        // Calculate scaling factor to fit the virtual width to the page width
        const ratio = pageWidth / VIRTUAL_WIDTH;
        // The resulting height of the scaled image on the PDF page
        const scaledImgHeight = TILE_HEIGHT * ratio;

        for (let i = 0; i < sections.length; i++) {
          const s = sections[i];
          const imgData = s.canvas.toDataURL('image/png', 1.0);
          
          if (i > 0) {
            pdf.addPage('a4', 'p');
          }
          
          // Image drawing with calculated scaling to ensure full width is visible
          // Coordinates (0,0) and dimensions (pageWidth, scaledImgHeight)
          pdf.addImage(imgData, 'PNG', 0, 0, pageWidth, scaledImgHeight, `sec_${i}`, 'FAST');
        }
        
        pdf.save('infinite_drawing_fit_width.pdf');
      } catch (err) {
        console.error("PDF Export Error:", err);
        alert('PDF download failed. Error: ' + err.message);
      } finally {
        pdfBtn.textContent = 'Download PDF';
        pdfBtn.disabled = false;
      }
    });

    exportBtn.addEventListener('click', () => {
      sections.forEach(s => {
        s.dataURL = s.canvas.toDataURL('image/png', 1.0);
      });
      const payload = {
        version: 2,
        virtualWidth: VIRTUAL_WIDTH,
        tileHeight: TILE_HEIGHT,
        sections: sections.map(s => ({ index: s.index, dataURL: s.dataURL }))
      };
      const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'drawing-backup.json';
      a.click();
      URL.revokeObjectURL(url);
    });

    importInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.sections) return;
        sections = [];
        container.innerHTML = '';
        data.sections.forEach((item, i) => {
          createSection(i, item.dataURL || null);
        });
        addSection();
        persistToLocalStorage();
        window.scrollTo({ top: 0, behavior: 'smooth' });
      } catch (err) {
        alert('Error loading file');
      } finally {
        importInput.value = '';
      }
    });

    sizePicker.addEventListener('input', () => {
      sizeLabel.textContent = sizePicker.value + ' px';
    });
    eraserBtn.addEventListener('click', () => {
      mode = 'eraser';
      eraserBtn.classList.add('primary');
      penBtn.classList.remove('primary');
    });
    penBtn.addEventListener('click', () => {
      mode = 'pen';
      penBtn.classList.add('primary');
      eraserBtn.classList.remove('primary');
    });
    clearSectionBtn.addEventListener('click', () => {
      const sec = findVisibleSection();
      if (!sec) return;
      sec.ctx.fillStyle = '#0a0f1c';
      sec.ctx.fillRect(0, 0, sec.canvas.width, sec.canvas.height);
      sec.dataURL = sec.canvas.toDataURL('image/png');
      persistToLocalStorage();
    });

    function findVisibleSection() {
      const centerY = window.scrollY + window.innerHeight / 2;
      let best = null, bestDist = Infinity;
      sections.forEach(s => {
        const rect = s.canvas.getBoundingClientRect();
        const top = rect.top + window.scrollY;
        const mid = top + rect.height / 2;
        const dist = Math.abs(mid - centerY);
        if (dist < bestDist) { bestDist = dist; best = s; }
      });
      return best;
    }

    (function init() {
      const data = loadFromLocalStorage();
      if (data && data.sections && data.sections.length > 0) {
        data.sections.forEach((item, i) => createSection(i, item.dataURL || null));
        addSection();
      } else {
        for (let i = 0; i < MIN_SECTIONS; i++) addSection();
      }
      ensureMoreSectionsIfNeeded();
    })();
  </script>
</body>
</html>
